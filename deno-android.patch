--- a/cli/build.rs
+++ b/cli/build.rs
@@ -374,13 +374,20 @@ fn main() {
     panic!("Cross compiling with snapshot is not supported.");
   }
 
-  let symbols_path = std::path::Path::new("napi").join(
-    format!("generated_symbol_exports_list_{}.def", env::consts::OS).as_str(),
-  )
-  .canonicalize()
-  .expect(
-    "Missing symbols list! Generate using tools/napi/generate_symbols_lists.js",
-  );
+  let symbols_file_name = match env::consts::OS {
+    "windows" => "generated_symbol_exports_list_windows.def".to_string(),
+    "macos" => "generated_symbol_exports_list_macos.def".to_string(),
+    "android" | "linux" => {
+      "generated_symbol_exports_list_linux.def".to_string()
+    }
+    os => format!("generated_symbol_exports_list_{}.def", os),
+  };
+  let symbols_path = std::path::Path::new("napi")
+    .join(symbols_file_name)
+    .canonicalize()
+    .expect(
+        "Missing symbols list! Generate using tools/napi/generate_symbols_lists.js",
+    );
 
   #[cfg(target_os = "windows")]
   println!(
@@ -413,6 +420,12 @@ fn main() {
     }
   }
 
+  #[cfg(target_os = "android")]
+  println!(
+    "cargo:rustc-link-arg-bin=deno=-Wl,--export-dynamic-symbol-list={}",
+    symbols_path.display()
+  );
+
   // To debug snapshot issues uncomment:
   // op_fetch_asset::trace_serializer();
 
--- a/cli/tsc/dts/lib.deno.ns.d.ts
+++ b/cli/tsc/dts/lib.deno.ns.d.ts
@@ -4958,6 +4958,7 @@ declare namespace Deno {
     os:
       | "darwin"
       | "linux"
+      | "android"
       | "windows"
       | "freebsd"
       | "netbsd"
--- a/ext/fs/30_fs.js
+++ b/ext/fs/30_fs.js
@@ -260,7 +260,7 @@ function createByteStruct(types) {
   // types can be "date", "bool" or "u64".
   let offset = 0;
   let str =
-    'const unix = Deno.build.os === "darwin" || Deno.build.os === "linux" || Deno.build.os === "openbsd" || Deno.build.os === "freebsd"; return {';
+    'const unix = Deno.build.os === "darwin" || Deno.build.os === "linux" || Deno.build.os === "android" || Deno.build.os === "openbsd" || Deno.build.os === "freebsd"; return {';
   const typeEntries = ObjectEntries(types);
   for (let i = 0; i < typeEntries.length; ++i) {
     let { 0: name, 1: type } = typeEntries[i];
@@ -325,8 +325,12 @@ const { 0: statStruct, 1: statBuf } = createByteStruct({
 });
 
 function parseFileInfo(response) {
-  const unix = core.build.os === "darwin" || core.build.os === "linux" ||
-    core.build.os === "freebsd" || core.build.os === "openbsd";
+  const unix =
+    core.build.os === "darwin" ||
+    core.build.os === "linux" ||
+    core.build.os === "android" ||
+    core.build.os === "freebsd" ||
+    core.build.os === "openbsd";
   return {
     isFile: response.isFile,
     isDirectory: response.isDirectory,
--- a/ext/fs/std_fs.rs
+++ b/ext/fs/std_fs.rs
@@ -62,7 +62,7 @@ impl FileSystem for RealFs {
       let _ = umask(prev);
       prev
     };
-    #[cfg(target_os = "linux")]
+    #[cfg(any(target_os = "android", target_os = "linux"))]
     {
       Ok(r.bits())
     }
--- a/ext/net/ops.rs
+++ b/ext/net/ops.rs
@@ -378,7 +378,7 @@ where
   #[cfg(not(windows))]
   socket.set_reuse_address(true)?;
   if reuse_port {
-    #[cfg(target_os = "linux")]
+    #[cfg(any(target_os = "android", target_os = "linux"))]
     socket.set_reuse_port(true)?;
   }
   let socket_addr = socket2::SockAddr::from(addr);
@@ -429,7 +429,7 @@ where
     // are different from the BSDs: it _shares_ the port rather than steal it
     // from the current listener. While useful, it's not something we can
     // emulate on other platforms so we don't enable it.
-    #[cfg(any(target_os = "windows", target_os = "linux"))]
+    #[cfg(any(target_os = "windows", target_os = "android", target_os = "linux"))]
     socket_tmp.set_reuse_address(true)?;
     #[cfg(all(unix, not(target_os = "linux")))]
     socket_tmp.set_reuse_port(true)?;
--- a/ext/net/ops_tls.rs
+++ b/ext/net/ops_tls.rs
@@ -471,7 +471,7 @@ where
   #[cfg(not(windows))]
   socket.set_reuse_address(true)?;
   if args.reuse_port {
-    #[cfg(target_os = "linux")]
+    #[cfg(any(target_os = "android", target_os = "linux"))]
     socket.set_reuse_port(true)?;
   }
   let socket_addr = socket2::SockAddr::from(bind_addr);
--- a/ext/node/ops/os/cpus.rs
+++ b/ext/node/ops/os/cpus.rs
@@ -236,7 +236,7 @@ pub fn cpu_info() -> Option<Vec<CpuInfo>> {
   }
 }
 
-#[cfg(target_os = "linux")]
+#[cfg(any(target_os = "android", target_os = "linux"))]
 pub fn cpu_info() -> Option<Vec<CpuInfo>> {
   use std::io::BufRead;
 
--- a/ext/node/polyfills/_util/os.ts
+++ b/ext/node/polyfills/_util/os.ts
@@ -3,9 +3,9 @@
 import { core } from "ext:core/mod.js";
 const ops = core.ops;
 
-export type OSType = "windows" | "linux" | "darwin" | "freebsd" | "openbsd";
+export type OSType = "windows" | "linux" | "android" | "darwin" | "freebsd" | "openbsd";
 
 export const osType: OSType = ops.op_node_build_os();
 
 export const isWindows = osType === "windows";
-export const isLinux = osType === "linux";
+export const isLinux = osType === "linux" || osType === "android";
--- a/ext/node/polyfills/internal_binding/constants.ts
+++ b/ext/node/polyfills/internal_binding/constants.ts
@@ -330,7 +330,7 @@ if (buildOs === "darwin") {
       PRIORITY_HIGHEST: -20,
     },
   };
-} else if (buildOs === "linux") {
+} else if (buildOs === "linux" || buildOs === "android") {
   os = {
     UV_UDP_REUSEADDR: 4,
     dlopen: {
--- a/ext/node/polyfills/internal_binding/uv.ts
+++ b/ext/node/polyfills/internal_binding/uv.ts
@@ -494,6 +494,8 @@ export const errorMap = new Map<number, [string, string]>(
     ? codeToErrorDarwin
     : osType === "linux"
     ? codeToErrorLinux
+    : osType === "android"
+    ? codeToErrorLinux
     : osType === "freebsd"
     ? codeToErrorFreebsd
     : osType === "openbsd"
@@ -508,6 +510,8 @@ export const codeMap = new Map<string, number>(
     ? errorToCodeDarwin
     : osType === "linux"
     ? errorToCodeLinux
+    : osType === "android"
+    ? errorToCodeLinux
     : osType === "freebsd"
     ? errorToCodeFreebsd
     : osType === "openbsd"
--- a/ext/node/polyfills/os.ts
+++ b/ext/node/polyfills/os.ts
@@ -151,7 +151,7 @@ export function endianness(): "BE" | "LE" {
 
 /** Return free memory amount */
 export function freemem(): number {
-  if (Deno.build.os === "linux") {
+  if (Deno.build.os === "linux" || Deno.build.os == "android") {
     // On linux, use 'available' memory
     // https://github.com/libuv/libuv/blob/a5c01d4de3695e9d9da34cfd643b5ff0ba582ea7/src/unix/linux.c#L2064
     return Deno.systemMemoryInfo().available;
@@ -176,6 +176,7 @@ export function homedir(): string | null {
     case "windows":
       return Deno.env.get("USERPROFILE") || null;
     case "linux":
+    case "android":
     case "darwin":
     case "freebsd":
     case "openbsd":
@@ -310,6 +311,7 @@ export function type(): string {
     case "windows":
       return "Windows_NT";
     case "linux":
+    case "android":
       return "Linux";
     case "darwin":
       return "Darwin";
--- a/runtime/ops/os/mod.rs
+++ b/runtime/ops/os/mod.rs
@@ -320,7 +320,7 @@ fn op_runtime_memory_usage(scope: &mut v8::HandleScope) -> MemoryUsage {
   }
 }
 
-#[cfg(target_os = "linux")]
+#[cfg(any(target_os = "android", target_os = "linux"))]
 fn rss() -> usize {
   // Inspired by https://github.com/Arc-blroth/memory-stats/blob/5364d0d09143de2a470d33161b2330914228fde9/src/linux.rs
 
--- a/runtime/ops/os/sys_info.rs
+++ b/runtime/ops/os/sys_info.rs
@@ -6,7 +6,7 @@ type LoadAvg = (f64, f64, f64);
 const DEFAULT_LOADAVG: LoadAvg = (0.0, 0.0, 0.0);
 
 pub fn loadavg() -> LoadAvg {
-  #[cfg(target_os = "linux")]
+  #[cfg(any(target_os = "android", target_os = "linux"))]
   {
     use libc::SI_LOAD_SHIFT;
 
@@ -57,6 +57,22 @@ pub fn os_release() -> String {
       _ => String::from(""),
     }
   }
+  #[cfg(target_os = "android")]
+  {
+    let mut info = std::mem::MaybeUninit::uninit();
+    // SAFETY: `info` is a valid pointer to a `libc::utsname` struct.
+    let res = unsafe { libc::uname(info.as_mut_ptr()) };
+    if res != 0 {
+      return String::from("");
+    }
+    // SAFETY: `uname` returns 0 on success, and `info` is initialized.
+    let mut info = unsafe { info.assume_init() };
+    let len = info.release.len();
+    info.release[len - 1] = 0;
+    // SAFETY: `info.release` is a valid pointer and NUL-terminated.
+    let c_str = unsafe { std::ffi::CStr::from_ptr(info.release.as_ptr()) };
+    c_str.to_string_lossy().into_owned()
+  }
   #[cfg(any(
     target_vendor = "apple",
     target_os = "freebsd",
@@ -198,7 +214,7 @@ pub fn mem_info() -> Option<MemInfo> {
     swap_total: 0,
     swap_free: 0,
   };
-  #[cfg(target_os = "linux")]
+  #[cfg(any(target_os = "android", target_os = "linux"))]
   {
     let mut info = std::mem::MaybeUninit::uninit();
     // SAFETY: `info` is a valid pointer to a `libc::sysinfo` struct.
@@ -343,7 +359,7 @@ pub fn mem_info() -> Option<MemInfo> {
 pub fn os_uptime() -> u64 {
   let uptime: u64;
 
-  #[cfg(target_os = "linux")]
+  #[cfg(any(target_os = "android", target_os = "linux"))]
   {
     let mut info = std::mem::MaybeUninit::uninit();
     // SAFETY: `info` is a valid pointer to a `libc::sysinfo` struct.
